<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mystery Trig â€” Alumno</title>
<style>
  :root{
    --bg1:#050816;
    --bg2:#0b1b3a;
    --card:#0b1224cc;
    --stroke:#ffffff14;
    --text:#e5e7eb;
    --muted:#a3b2c7;
    --accent:#38bdf8;
    --gold:#fbbf24;
    --good:#22c55e;
    --bad:#ef4444;
  }

  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    background:
      radial-gradient(900px 600px at 20% 10%, rgba(56,189,248,.22), transparent 60%),
      radial-gradient(900px 600px at 80% 20%, rgba(251,191,36,.18), transparent 55%),
      radial-gradient(900px 600px at 50% 90%, rgba(34,197,94,.12), transparent 55%),
      linear-gradient(160deg, var(--bg1), var(--bg2));
    overflow-x:hidden;
  }

  .wrap{max-width:980px;margin:0 auto;padding:26px 16px 40px}
  .brand{
    display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px
  }
  .logo{
    display:flex;align-items:center;gap:10px;
    font-weight:900; letter-spacing:.4px;
  }
  .badge{
    background:linear-gradient(90deg, rgba(56,189,248,.22), rgba(251,191,36,.18));
    border:1px solid var(--stroke);
    padding:6px 10px;border-radius:999px;color:var(--muted);font-size:12px
  }

  .card{
    background:var(--card);
    border:1px solid var(--stroke);
    border-radius:18px;
    box-shadow: 0 18px 60px rgba(0,0,0,.45);
    backdrop-filter: blur(10px);
    padding:18px;
  }

  .grid2{
    display:grid;grid-template-columns:1.2fr .8fr;gap:14px
  }
  @media (max-width:900px){ .grid2{grid-template-columns:1fr} }

  .title{margin:2px 0 6px;font-size:24px;font-weight:900}
  .sub{margin:0 0 14px;color:var(--muted);line-height:1.35}

  .row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:620px){ .row{grid-template-columns:1fr} }

  label{display:block;text-align:left;font-size:12px;color:var(--muted);margin:2px 0 6px}
  input{
    width:100%; padding:12px 12px;
    border-radius:14px;
    background:#0a1630;
    border:1px solid var(--stroke);
    color:var(--text);
    outline:none;
  }
  input:focus{border-color:rgba(56,189,248,.45); box-shadow:0 0 0 4px rgba(56,189,248,.14)}

  .btn{
    width:100%;
    border:0;
    border-radius:14px;
    padding:12px 14px;
    font-weight:900;
    color:#061018;
    cursor:pointer;
    background:linear-gradient(90deg, var(--accent), #60a5fa);
    box-shadow: 0 10px 24px rgba(56,189,248,.18);
  }
  .btn:disabled{opacity:.6;cursor:not-allowed}

  .btn2{
    width:100%;
    border:1px solid var(--stroke);
    border-radius:14px;
    padding:12px 14px;
    font-weight:800;
    color:var(--text);
    cursor:pointer;
    background:linear-gradient(90deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
  }

  .pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:8px 10px;border-radius:999px;
    border:1px solid var(--stroke);
    background:rgba(255,255,255,.03);
    color:var(--muted);
    font-size:12px;
  }

  .panel{
    display:flex;flex-direction:column;gap:12px
  }

  .hud{
    display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between
  }
  .hud-left{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .hud-right{display:flex;gap:10px;align-items:center}

  .qbox{margin-top:10px}
  .qtitle{font-size:18px;font-weight:900;margin:6px 0 8px}
  .options{display:grid;gap:10px}
  .opt{
    text-align:left;
    border:1px solid var(--stroke);
    border-radius:16px;
    padding:12px 12px;
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    cursor:pointer;
    user-select:none;
    transition:transform .08s ease, border-color .18s ease;
  }
  .opt:hover{transform:translateY(-1px);border-color:rgba(56,189,248,.35)}
  .opt.disabled{opacity:.55;pointer-events:none}

  .feedback{min-height:22px;font-weight:900;margin-top:10px}
  .ok{color:var(--good)}
  .bad{color:var(--bad)}
  .warn{color:var(--gold)}

  /* Overlay */
  .overlay{
    position:fixed; inset:0;
    display:none;
    align-items:center; justify-content:center;
    background:radial-gradient(800px 500px at 50% 40%, rgba(56,189,248,.18), rgba(0,0,0,.72));
    z-index:1000;
    padding:18px;
  }
  .overlay.show{display:flex}
  .modal{
    width:min(760px, 100%);
    border-radius:22px;
    border:1px solid var(--stroke);
    background:rgba(8,15,30,.72);
    backdrop-filter: blur(14px);
    box-shadow: 0 18px 70px rgba(0,0,0,.55);
    padding:18px;
    text-align:center;
  }
  .modal h2{margin:8px 0 6px;font-size:26px;font-weight:950}
  .modal p{margin:0;color:var(--muted);line-height:1.4}
  .big{
    margin-top:14px;
    font-size:74px;
    font-weight:1000;
    letter-spacing:1px;
    color:#fff;
    text-shadow: 0 0 22px rgba(56,189,248,.35);
  }
  .spark{
    display:inline-block;
    padding:8px 12px;
    border-radius:999px;
    border:1px solid var(--stroke);
    background:linear-gradient(90deg, rgba(251,191,36,.20), rgba(56,189,248,.18));
    margin-top:10px;
    font-weight:900;
  }

  .hidden{display:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="brand">
    <div class="logo">
      <div style="width:34px;height:34px;border-radius:12px;background:linear-gradient(135deg,#38bdf8,#fbbf24);box-shadow:0 12px 30px rgba(56,189,248,.18)"></div>
      <div>
        <div style="font-size:14px;color:var(--muted);font-weight:800;letter-spacing:.2px">Mystery Picture</div>
        <div style="font-size:20px;font-weight:1000;line-height:1">Trig Race</div>
      </div>
    </div>
    <div class="badge">One Piece â€¢ Lobby â€¢ Countdown</div>
  </div>

  <div class="grid2">
    <!-- Left -->
    <div class="card" id="loginCard">
      <div class="title">Ingresa tu equipo</div>
      <div class="sub">MÃ¡ximo 2 alumnos por equipo. Alumno 1 es obligatorio.</div>

      <div class="row">
        <div>
          <label>Alumno 1 (obligatorio)</label>
          <input id="student1" maxlength="26" placeholder="Nombre y apellido" />
        </div>
        <div>
          <label>Alumno 2 (opcional)</label>
          <input id="student2" maxlength="26" placeholder="Nombre y apellido (opcional)" />
        </div>
      </div>

      <div style="height:10px"></div>
      <button class="btn" id="btnEnter">Entrar</button>

      <div style="height:10px"></div>
      <div class="pill">Al entrar, se asignarÃ¡ un personaje aleatorio de One Piece (Ãºnico) como nombre de equipo.</div>
    </div>

    <!-- Right -->
    <div class="card panel" id="playCard">
      <div class="hud">
        <div class="hud-left">
          <span class="pill" id="teamPill">Equipo: â€”</span>
          <span class="pill" id="progressPill">Progreso global: 0 / 300</span>
          <span class="pill" id="qidPill">Reactivo: â€”</span>
        </div>
        <div class="hud-right">
          <button class="btn2" id="btnSkip" title="Libera el reactivo actual y pide otro">Cambiar reactivo</button>
        </div>
      </div>

      <div class="qbox">
        <div class="qtitle" id="question">â€”</div>
        <div class="options" id="options"></div>
        <div class="feedback" id="feedback"></div>
      </div>
    </div>
  </div>
</div>

<!-- Overlay: waiting/countdown -->
<div class="overlay" id="overlay">
  <div class="modal">
    <h2 id="overlayTitle">Esperando al hostâ€¦</h2>
    <p id="overlayText">Permanece en esta pantalla. La partida comenzarÃ¡ en breve.</p>
    <div class="spark" id="overlayTeam">Equipo: â€”</div>
    <div class="big" id="overlayBig" style="display:none">5</div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import { getAuth, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
import {
  getDatabase, ref, set, update, onValue, runTransaction, remove, get
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";

/* ===== Firebase config (tuyo) ===== */
const firebaseConfig = {
  apiKey: "AIzaSyAcud6YPUTHkfS-Liyo2lAvZV5cwHzueIk",
  authDomain: "mystery-bde3e.firebaseapp.com",
  databaseURL: "https://mystery-bde3e-default-rtdb.firebaseio.com",
  projectId: "mystery-bde3e",
  storageBucket: "mystery-bde3e.firebasestorage.app",
  messagingSenderId: "443989171807",
  appId: "1:443989171807:web:a19f4b6a0783bd472585ea"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

/* ===== Game ID ===== */
const GAME_ID = "trig-mystery-20x15-v1";

/* ===== RTDB paths ===== */
const solvedRef = ref(db, `games/${GAME_ID}/solved`);
const locksRef  = ref(db, `games/${GAME_ID}/locks`);
const teamsRef  = ref(db, `games/${GAME_ID}/teams`);
const claimedRef = ref(db, `games/${GAME_ID}/claimedCharacters`); // { key: {uid, teamKey, ts, name, emoji} }
const stateRef  = ref(db, `games/${GAME_ID}/state`);              // { phase, countdownEndsAt }
const resetCounterRef = ref(db, `games/${GAME_ID}/resetCounter`);
const offsetRef = ref(db, ".info/serverTimeOffset");

/* ===== One Piece characters pool (amplia si quieres) ===== */
const OP = [
  {key:"luffy", name:"Luffy", emoji:"ðŸ´â€â˜ ï¸"},
  {key:"zoro", name:"Zoro", emoji:"ðŸ—¡ï¸"},
  {key:"nami", name:"Nami", emoji:"ðŸ§­"},
  {key:"sanji", name:"Sanji", emoji:"ðŸ‘¨â€ðŸ³"},
  {key:"usopp", name:"Usopp", emoji:"ðŸ¹"},
  {key:"chopper", name:"Chopper", emoji:"ðŸ¦Œ"},
  {key:"robin", name:"Robin", emoji:"ðŸ“š"},
  {key:"franky", name:"Franky", emoji:"ðŸ¦¾"},
  {key:"brook", name:"Brook", emoji:"ðŸŽ»"},
  {key:"jinbe", name:"Jinbe", emoji:"ðŸŒŠ"},
  {key:"ace", name:"Ace", emoji:"ðŸ”¥"},
  {key:"law", name:"Law", emoji:"âš•ï¸"},
  {key:"shanks", name:"Shanks", emoji:"ðŸ·"},
  {key:"mihawk", name:"Mihawk", emoji:"ðŸ¦…"},
  {key:"boa", name:"Hancock", emoji:"ðŸ"},
  {key:"sabo", name:"Sabo", emoji:"ðŸŽ©"},
  {key:"kaido", name:"Kaido", emoji:"ðŸ‰"},
  {key:"bigmom", name:"Big Mom", emoji:"ðŸ°"},
  {key:"yamato", name:"Yamato", emoji:"ðŸ¦Š"},
  {key:"buggy", name:"Buggy", emoji:"ðŸ¤¡"},
  {key:"blackbeard", name:"Teach", emoji:"âš“"},
  {key:"kidd", name:"Kid", emoji:"ðŸ§²"},
  {key:"smoker", name:"Smoker", emoji:"ðŸš¬"},
  {key:"crocodile", name:"Crocodile", emoji:"ðŸŠ"},
  {key:"doflamingo", name:"Doflamingo", emoji:"ðŸ¦©"},
];

/* ===== Local question bank (300) ===== */
const questionBank = [];
let qid = 1;

function shuffle(arr){
  const a = [...arr];
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function pushQ(q, opts, ansIndex){
  questionBank.push({ id: qid++, question: q, options: opts, answer: ansIndex });
}

const ratioDefs = [
  {name:"sin(x)", correct:"cateto opuesto / hipotenusa", distract:["cateto adyacente / hipotenusa","cateto opuesto / cateto adyacente"]},
  {name:"cos(x)", correct:"cateto adyacente / hipotenusa", distract:["cateto opuesto / hipotenusa","cateto opuesto / cateto adyacente"]},
  {name:"tan(x)", correct:"cateto opuesto / cateto adyacente", distract:["cateto adyacente / hipotenusa","cateto opuesto / hipotenusa"]},
];

const sideId = [
  {q:"Respecto al Ã¡ngulo x, Â¿cuÃ¡l es la hipotenusa?", opts:["El lado opuesto al Ã¡ngulo recto","El cateto que toca al Ã¡ngulo x","El cateto frente al Ã¡ngulo x"], ans:0},
  {q:"Respecto al Ã¡ngulo x, el cateto adyacente es:", opts:["El cateto que toca al Ã¡ngulo x","El lado opuesto al Ã¡ngulo recto","El cateto frente al Ã¡ngulo x"], ans:0},
  {q:"Respecto al Ã¡ngulo x, el cateto opuesto es:", opts:["El cateto frente al Ã¡ngulo x","El lado opuesto al Ã¡ngulo recto","El cateto que toca al Ã¡ngulo x"], ans:0},
];

const interpret = [
  {q:"Si tan(x)=7/4, el 7 representa:", opts:["cateto opuesto","cateto adyacente","hipotenusa"], ans:0},
  {q:"Si cos(x)=12/13, el 13 representa:", opts:["hipotenusa","cateto opuesto","cateto adyacente"], ans:0},
  {q:"Si sin(x)=3/5, el 3 representa:", opts:["cateto opuesto","hipotenusa","cateto adyacente"], ans:0},
];

while(questionBank.length < 300){
  for(const r of ratioDefs){
    if(questionBank.length >= 300) break;
    const opts = shuffle([r.correct, ...r.distract]);
    pushQ(`Selecciona la definiciÃ³n correcta de ${r.name}:`, opts, opts.indexOf(r.correct));
  }
  for(const s of sideId){
    if(questionBank.length >= 300) break;
    pushQ(s.q, s.opts, s.ans);
  }
  for(const t of interpret){
    if(questionBank.length >= 300) break;
    pushQ(t.q, t.opts, t.ans);
  }
}

const bankById = new Map(questionBank.map(q => [q.id, q]));

/* ===== UI refs ===== */
const loginCard = document.getElementById("loginCard");
const playCard = document.getElementById("playCard");
const btnEnter = document.getElementById("btnEnter");
const btnSkip = document.getElementById("btnSkip");
const student1Input = document.getElementById("student1");
const student2Input = document.getElementById("student2");

const teamPill = document.getElementById("teamPill");
const progressPill = document.getElementById("progressPill");
const qidPill = document.getElementById("qidPill");

const questionEl = document.getElementById("question");
const optionsEl = document.getElementById("options");
const feedbackEl = document.getElementById("feedback");

const overlay = document.getElementById("overlay");
const overlayTitle = document.getElementById("overlayTitle");
const overlayText = document.getElementById("overlayText");
const overlayTeam = document.getElementById("overlayTeam");
const overlayBig = document.getElementById("overlayBig");

/* ===== state ===== */
let uid = null;
let teamKey = null; // key for teams node
let teamLabel = "â€”"; // "Name emoji"
let currentQid = null;
let locked = false;

let solvedCache = {};
let localResetCounter = null;

let serverOffset = 0;
let gameState = { phase: "lobby" };
let countdownTimer = null;

function safeKey(s){ return s.replace(/[.#$\[\]\/]/g, "_"); }
function setFeedback(text, cls){
  feedbackEl.textContent = text || "";
  feedbackEl.className = "feedback " + (cls || "");
}
function setOptionsDisabled(){
  optionsEl.querySelectorAll(".opt").forEach(o => o.classList.add("disabled"));
}
function renderQuestion(q){
  questionEl.textContent = q.question;
  optionsEl.innerHTML = "";
  q.options.forEach((opt, i) => {
    const div = document.createElement("div");
    div.className = "opt";
    div.textContent = opt;
    div.addEventListener("click", () => checkAnswer(i), { once:true });
    optionsEl.appendChild(div);
  });
}
function serverNow(){ return Date.now() + (serverOffset || 0); }

function showOverlay(type){
  overlay.classList.add("show");
  overlayBig.style.display = "none";

  if(type === "waiting"){
    overlayTitle.textContent = "Esperando al hostâ€¦";
    overlayText.textContent  = "Cuando todos estÃ©n listos, el host iniciarÃ¡ la partida.";
    overlayBig.style.display = "none";
  }
  if(type === "countdown"){
    overlayTitle.textContent = "Â¡Comienza enâ€¦!";
    overlayText.textContent  = "PrepÃ¡rate para desbloquear el misterio.";
    overlayBig.style.display = "block";
  }
}
function hideOverlay(){
  overlay.classList.remove("show");
}

/* ===== listeners ===== */
onValue(offsetRef, (snap) => { serverOffset = snap.val() || 0; });

onValue(solvedRef, (snap) => {
  solvedCache = snap.val() || {};
  const solvedCount = Object.keys(solvedCache).length;
  progressPill.textContent = `Progreso global: ${solvedCount} / 300`;
});

onValue(stateRef, (snap) => {
  gameState = snap.val() || { phase: "lobby" };
  handlePhaseChange();
});

onValue(resetCounterRef, async (snap) => {
  const rc = snap.val() ?? 0;
  if(localResetCounter === null){ localResetCounter = rc; return; }
  if(rc !== localResetCounter){
    localResetCounter = rc;
    await forceBackToHome("La partida fue reiniciada por el host.");
  }
});

/* ===== auth boot ===== */
onAuthStateChanged(auth, async (user) => {
  if(user){
    uid = user.uid;
    // Entra en modo lobby (sin juego hasta que host inicie)
    playCard.classList.add("hidden"); // solo aparece cuando phase=live
    hideOverlay();
  }else{
    await signInAnonymously(auth);
  }
});

/* ===== enter ===== */
btnEnter.addEventListener("click", async () => {
  const s1 = student1Input.value.trim();
  const s2 = student2Input.value.trim();

  if(!s1) return alert("Alumno 1 es obligatorio.");
  if(s1.length > 26 || s2.length > 26) return alert("MÃ¡ximo 26 caracteres por nombre.");

  btnEnter.disabled = true;

  try{
    // crear teamKey por uid para evitar duplicados
    teamKey = uid;
    const claimed = await claimOnePieceCharacter(teamKey);

    teamLabel = `${claimed.emoji} ${claimed.name}`;
    teamPill.textContent = `Equipo: ${teamLabel}`;
    overlayTeam.textContent = `Equipo: ${teamLabel}`;

    // guardar team en DB
    await set(ref(db, `games/${GAME_ID}/teams/${teamKey}`), {
      teamKey,
      uid,
      teamLabel,
      characterKey: claimed.key,
      student1: s1,
      student2: s2 || "",
      solvedCount: 0,
      lastSeen: Date.now(),
      joinedAt: Date.now(),
    });

    // heartbeat
    setInterval(() => {
      if(teamKey){
        update(ref(db, `games/${GAME_ID}/teams/${teamKey}`), { lastSeen: Date.now() });
      }
    }, 15000);

    // UI: ocultar login, mostrar overlay de espera; el juego aparece cuando phase=live
    loginCard.classList.add("hidden");
    showOverlay("waiting");
    // si el host ya estÃ¡ en countdown/live, se sincroniza por handlePhaseChange()
    handlePhaseChange();
  } catch(e){
    console.error(e);
    alert("No se pudo ingresar. Intenta de nuevo.");
    btnEnter.disabled = false;
  }
});

btnSkip.addEventListener("click", async () => {
  if(!teamKey) return;
  if(gameState.phase !== "live") return;
  if(currentQid != null) await releaseLock(currentQid);
  await nextQuestion();
});

/* ===== character claim (Ãºnico) ===== */
async function claimOnePieceCharacter(teamKey){
  // intentar 40 veces tomar un personaje disponible
  for(let attempt=0; attempt<40; attempt++){
    const pick = OP[Math.floor(Math.random() * OP.length)];
    const spot = ref(db, `games/${GAME_ID}/claimedCharacters/${pick.key}`);

    const tx = await runTransaction(spot, (current) => {
      if(current == null){
        return { key: pick.key, name: pick.name, emoji: pick.emoji, uid, teamKey, ts: Date.now() };
      }
      return; // abort
    }, { applyLocally:false });

    if(tx.committed){
      return pick;
    }
  }

  // fallback: bÃºsqueda lineal
  for(const pick of OP){
    const spot = ref(db, `games/${GAME_ID}/claimedCharacters/${pick.key}`);
    const tx = await runTransaction(spot, (current) => {
      if(current == null){
        return { key: pick.key, name: pick.name, emoji: pick.emoji, uid, teamKey, ts: Date.now() };
      }
      return;
    }, { applyLocally:false });

    if(tx.committed){
      return pick;
    }
  }

  throw new Error("No hay personajes disponibles.");
}

/* ===== phase handling ===== */
function handlePhaseChange(){
  if(!teamKey){
    // aÃºn no ingresÃ³ equipo
    return;
  }

  // Si no hay estado, tratamos como lobby
  const phase = gameState?.phase || "lobby";

  if(phase === "lobby"){
    playCard.classList.add("hidden");
    showOverlay("waiting");
    stopCountdownLoop();
    return;
  }

  if(phase === "countdown"){
    playCard.classList.add("hidden");
    showOverlay("countdown");
    startCountdownLoop(gameState.countdownEndsAt);
    return;
  }

  if(phase === "live"){
    stopCountdownLoop();
    hideOverlay();
    playCard.classList.remove("hidden");
    // iniciar preguntas si aÃºn no tiene
    if(currentQid == null){
      nextQuestion();
    }
  }
}

function startCountdownLoop(endsAt){
  stopCountdownLoop();
  if(!endsAt){
    overlayBig.textContent = "5";
    return;
  }

  countdownTimer = setInterval(() => {
    const leftMs = endsAt - serverNow();
    const left = Math.max(0, Math.ceil(leftMs / 1000));
    overlayBig.textContent = String(left);

    if(left <= 0){
      // La transiciÃ³n a "live" la hace el host; aquÃ­ solo esperamos el cambio real de estado
      overlayBig.textContent = "0";
    }
  }, 120);
}

function stopCountdownLoop(){
  if(countdownTimer){
    clearInterval(countdownTimer);
    countdownTimer = null;
  }
}

/* ===== Locks / solved logic ===== */
async function nextQuestion(){
  locked = false;
  setFeedback("", "");
  const solvedIds = new Set(Object.keys(solvedCache).map(n => Number(n)));

  if(solvedIds.size >= 300){
    questionEl.textContent = "Â¡Banco completado!";
    optionsEl.innerHTML = "";
    qidPill.textContent = "Reactivo: â€”";
    setFeedback("âœ… Se completÃ³ el misterio.", "ok");
    return;
  }

  setFeedback("Buscando reactivoâ€¦", "warn");

  for(let attempt=0; attempt<30; attempt++){
    const qid = pickRandomUnsolved(solvedIds);
    if(qid == null) break;

    const ok = await tryLock(qid);
    if(ok){
      currentQid = qid;
      qidPill.textContent = `Reactivo: ${qid}`;
      renderQuestion(bankById.get(qid));
      setFeedback("", "");
      return;
    }
  }

  setFeedback("Alta concurrencia, reintentandoâ€¦", "warn");
  setTimeout(nextQuestion, 600);
}

function pickRandomUnsolved(solvedIds){
  for(let k=0; k<70; k++){
    const qid = 1 + Math.floor(Math.random() * 300);
    if(!solvedIds.has(qid)) return qid;
  }
  for(let qid=1; qid<=300; qid++){
    if(!solvedIds.has(qid)) return qid;
  }
  return null;
}

async function tryLock(qid){
  const lockPath = ref(db, `games/${GAME_ID}/locks/${qid}`);
  const now = Date.now();
  const LOCK_TTL_MS = 2 * 60 * 1000;

  const result = await runTransaction(lockPath, (current) => {
    if(solvedCache && solvedCache[String(qid)] === true) return;

    if(current == null) return { uid, teamKey, ts: now };

    if(current && typeof current.ts === "number" && (now - current.ts) > LOCK_TTL_MS){
      return { uid, teamKey, ts: now };
    }

    if(current && current.uid === uid){
      return { uid, teamKey, ts: now };
    }

    return;
  }, { applyLocally:false });

  return result.committed;
}

async function releaseLock(qid){
  const lockPath = ref(db, `games/${GAME_ID}/locks/${qid}`);
  await runTransaction(lockPath, (current) => {
    if(current && current.uid === uid) return null;
    return;
  }, { applyLocally:false });
}

async function markSolved(qid){
  await set(ref(db, `games/${GAME_ID}/solved/${qid}`), true);
  await releaseLock(qid);

  const teamSolvedRef = ref(db, `games/${GAME_ID}/teams/${teamKey}/solvedCount`);
  await runTransaction(teamSolvedRef, (v) => (typeof v === "number" ? v + 1 : 1), { applyLocally:false });
}

async function checkAnswer(selectedIndex){
  if(locked) return;
  locked = true;
  setOptionsDisabled();

  const q = bankById.get(currentQid);
  const correct = (selectedIndex === q.answer);

  if(correct){
    setFeedback("âœ” Correcto â€” tile desbloqueado", "ok");
    await markSolved(currentQid);
  }else{
    setFeedback("âœ– Incorrecto â€” regresa al pool", "bad");
    await releaseLock(currentQid);
  }

  setTimeout(nextQuestion, 520);
}

/* ===== Force back to home on reset ===== */
async function forceBackToHome(message){
  try{
    if(teamKey && currentQid != null){
      await releaseLock(currentQid);
    }
  }catch(e){}

  currentQid = null;
  locked = false;

  // limpiar UI
  playCard.classList.add("hidden");
  loginCard.classList.remove("hidden");
  student1Input.value = "";
  student2Input.value = "";
  teamPill.textContent = "Equipo: â€”";
  qidPill.textContent = "Reactivo: â€”";
  questionEl.textContent = "â€”";
  optionsEl.innerHTML = "";
  setFeedback(message || "Regresando al inicioâ€¦", "warn");

  // borrar team node (opcional) â€” el dashboard tambiÃ©n lo limpia en reset
  if(teamKey){
    try{ await remove(ref(db, `games/${GAME_ID}/teams/${teamKey}`)); }catch(e){}
  }

  teamKey = null;
  teamLabel = "â€”";
  showOverlay("waiting");
  overlayTitle.textContent = "Partida reiniciada";
  overlayText.textContent = "Vuelve a ingresar tu equipo.";
}
</script>
</body>
</html>
